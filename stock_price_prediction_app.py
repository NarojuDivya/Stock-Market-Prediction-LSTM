# -*- coding: utf-8 -*-
"""Copy of 📊Stock Market Analysis 📈 + Prediction using LSTM

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1baAI_W2mu0OKyV1s-7y_Jv145Pw4VC4q
"""

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.

rpaguirre_tesla_stock_price_path = kagglehub.dataset_download('rpaguirre/tesla-stock-price')
camnugent_sandp500_path = kagglehub.dataset_download('camnugent/sandp500')
hershyandrew_amzn_dpz_btc_ntfx_adjusted_may_2013may2019_path = kagglehub.dataset_download('hershyandrew/amzn-dpz-btc-ntfx-adjusted-may-2013may2019')
tarunpaparaju_apple_aapl_historical_stock_data_path = kagglehub.dataset_download('tarunpaparaju/apple-aapl-historical-stock-data')

print('Data source import complete.')

"""# Data Project - Stock Market Analysis

![techAnalysis-1000x500.jpg](attachment:techAnalysis-1000x500.jpg)

Time Series data is a series of data points indexed in time order. Time series data is everywhere, so manipulating them is important for any data analyst or data scientist.

In this notebook, we will discover and explore data from the stock market, particularly some technology stocks (Apple, Amazon, Google, and Microsoft). We will learn how to use yfinance to get stock information, and visualize different aspects of it using Seaborn and Matplotlib. we will look at a few ways of analyzing the risk of a stock, based on its previous performance history. We will also be predicting future stock prices through a Long Short Term Memory (LSTM) method!

We'll be answering the following questions along the way:

    1.) What was the change in price of the stock over time?
    2.) What was the daily return of the stock on average?
    3.) What was the moving average of the various stocks?
    4.) What was the correlation between different stocks'?
    5.) How much value do we put at risk by investing in a particular stock?
    6.) How can we attempt to predict future stock behavior? (Predicting the closing price stock price of APPLE inc using LSTM)

***   

## Getting the Data
The first step is to get the data and load it to memory. We will get our stock data from the Yahoo Finance website. Yahoo Finance is a rich resource of financial market data and tools to find compelling investments. To get the data from Yahoo Finance, we will be using yfinance library which offers a threaded and Pythonic way to download market data from Yahoo. Check this article to learn more about yfinance: [Reliably download historical market data from with Python](https://aroussi.com/post/python-yahoo-finance)

# 1. What was the change in price of the stock overtime?

In this section we'll go over how to handle requesting stock information with pandas, and how to analyze basic attributes of a stock.
"""



# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style('whitegrid')
plt.style.use("fivethirtyeight")
# %matplotlib inline

# For reading stock data from yahoo
from pandas_datareader.data import DataReader
import yfinance as yf
import pandas_datareader.data as pdr


# For time stamps
from datetime import datetime


# The tech stocks we'll use for this analysis
tech_list = ['AAPL', 'GOOG', 'MSFT', 'AMZN']

# Set up End and Start times for data grab
tech_list = ['AAPL', 'GOOG', 'MSFT', 'AMZN']

end = datetime.now()
start = datetime(end.year - 1, end.month, end.day)

stock_data = {}
for stock in tech_list:
    stock_data[stock] = yf.download(stock, start, end)


company_list = [stock_data['AAPL'], stock_data['GOOG'], stock_data['MSFT'], stock_data['AMZN']]
company_name = ["APPLE", "GOOGLE", "MICROSOFT", "AMAZON"]


for company, name in zip(company_list, company_name):
    company["company_name"] = name

df = pd.concat(company_list, axis=0)
df.tail(10)

"""Reviewing the content of our data, we can see that the data is numeric and the date is the index of the data. Notice also that weekends are missing from the records.

**Quick note:** Using `globals()` is a sloppy way of setting the `DataFrame` names, but it's simple. Now we have our data, let's perform some basic data analysis and check our data.

## Descriptive Statistics about the Data
`.describe()` generates descriptive statistics. Descriptive statistics include those that summarize the central tendency, dispersion, and shape of a dataset’s distribution, excluding `NaN` values.

Analyzes both numeric and object series, as well as `DataFrame` column sets of mixed data types. The output will vary depending on what is provided. Refer to the notes below for more detail.
"""

import yfinance as yf
import pandas as pd

# ✅ Download data from Yahoo Finance
AAPL = yf.download('AAPL', period='1y')
GOOG = yf.download('GOOG', period='1y')
MSFT = yf.download('MSFT', period='1y')
AMZN = yf.download('AMZN', period='1y')

# ✅ Now this will work without any error
print("Summary Statistics for APPLE")
print(AAPL.describe())

print("\nSummary Statistics for GOOGLE")
print(GOOG.describe())

print("\nSummary Statistics for MICROSOFT")
print(MSFT.describe())

print("\nSummary Statistics for AMAZON")
print(AMZN.describe())

"""We have only 255 records in one year because weekends are not included in the data.

## Information About the Data
`.info()` method prints information about a DataFrame including the index `dtype` and columns, non-null values, and memory usage.
"""

# General info
AAPL.info()
GOOG.info()
MSFT.info()
AMZN.info()

"""## Closing Price

The closing price is the last price at which the stock is traded during the regular trading day. A stock’s closing price is the standard benchmark used by investors to track its performance over time.
"""

# Beautiful Stock Price Plots (With Separate Graphs)
colors = ['#FF5733', '#33FF57', '#3357FF', '#FF33A1']

for i, (company, color) in enumerate(zip(company_list, colors)):
    plt.figure(figsize=(12, 6))

    # Plot the closing price with color
    company['Close'].plot(color=color, linewidth=2)

    # Add graph details
    plt.ylabel('Closing Price (in $)')
    plt.xlabel('Date')
    plt.title(f"Closing Price of {company_name[i]}", fontsize=16)

    # Add grid and show plot
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.show()

"""## Volume of Sales
Volume is the amount of an asset or security that changes hands over some period of time, often over the course of a day. For instance, the stock trading volume would refer to the number of shares of security traded between its daily open and close. Trading volume, and changes to volume over the course of time, are important inputs for technical traders.
"""

# Plot the total stock trading volume for each company
for i, (company, name) in enumerate(zip(company_list, company_name)):
    plt.figure(figsize=(12, 6))

    # Check if Volume column exists to avoid KeyError
    if 'Volume' in company.columns:
        company['Volume'].plot(color='purple', alpha=0.7, linewidth=1.5)
    else:
        print(f"⚠ No 'Volume' data found for {name}")
        continue

    # Add labels and title
    plt.ylabel('Trading Volume')
    plt.xlabel('Date')
    plt.title(f"Trading Volume for {name}", fontsize=16)

    # Add grid lines
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.show()

"""Now that we've seen the visualizations for the closing price and the volume traded each day, let's go ahead and caculate the moving average for the stock.

# 2. What was the moving average of the various stocks?

The moving average (MA) is a simple technical analysis tool that smooths out price data by creating a constantly updated average price. The average is taken over a specific period of time, like 10 days, 20 minutes, 30 weeks, or any time period the trader chooses.
"""

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt

# ✅ Download data from Yahoo Finance
AAPL = yf.download('AAPL', period='1y')
GOOG = yf.download('GOOG', period='1y')
MSFT = yf.download('MSFT', period='1y')
AMZN = yf.download('AMZN', period='1y')

# ✅ Calculate Moving Averages
AAPL['MA for 10 days'] = AAPL['Close'].rolling(window=10).mean()
AAPL['MA for 20 days'] = AAPL['Close'].rolling(window=20).mean()
AAPL['MA for 50 days'] = AAPL['Close'].rolling(window=50).mean()

GOOG['MA for 10 days'] = GOOG['Close'].rolling(window=10).mean()
GOOG['MA for 20 days'] = GOOG['Close'].rolling(window=20).mean()
GOOG['MA for 50 days'] = GOOG['Close'].rolling(window=50).mean()

MSFT['MA for 10 days'] = MSFT['Close'].rolling(window=10).mean()
MSFT['MA for 20 days'] = MSFT['Close'].rolling(window=20).mean()
MSFT['MA for 50 days'] = MSFT['Close'].rolling(window=50).mean()

AMZN['MA for 10 days'] = AMZN['Close'].rolling(window=10).mean()
AMZN['MA for 20 days'] = AMZN['Close'].rolling(window=20).mean()
AMZN['MA for 50 days'] = AMZN['Close'].rolling(window=50).mean()

# ✅ Function to plot moving averages
def plot_moving_average(company, ax, company_name):
    ax.plot(company.index, company['Close'], color='blue', label='Close Price', linewidth=2, alpha=0.8)

    # ✅ Smooth Moving Averages
    ax.plot(company.index, company['MA for 10 days'], color='red', linestyle='--', label='MA for 10 days', linewidth=1.5)
    ax.plot(company.index, company['MA for 20 days'], color='green', linestyle='-.', label='MA for 20 days', linewidth=1.5)
    ax.plot(company.index, company['MA for 50 days'], color='orange', linestyle='dotted', label='MA for 50 days', linewidth=1.5)

    # ✅ Set title and legend
    ax.set_title(company_name, fontsize=14, fontweight='bold')
    ax.legend(loc='upper left')
    ax.grid(True, linestyle='--', alpha=0.7)

# ✅ Create subplots
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(15, 10))
fig.suptitle('📊 Stock Prices with Moving Averages (Smoothed)', fontsize=18, fontweight='bold')

# ✅ Plot for each company
plot_moving_average(AAPL, axes[0,0], '🍏 APPLE')
plot_moving_average(GOOG, axes[0,1], '🔎 GOOGLE')
plot_moving_average(MSFT, axes[1,0], '💻 MICROSOFT')
plot_moving_average(AMZN, axes[1,1], '📦 AMAZON')

# ✅ Improve layout
fig.subplots_adjust(hspace=0.3, wspace=0.3)

# ✅ Show the plot
plt.show()

"""We see in the graph that the best values to measure the moving average are 10 and 20 days because we still capture trends in the data without noise.

# 3. What was the daily return of the stock on average?

Now that we've done some baseline analysis, let's go ahead and dive a little deeper. We're now going to analyze the risk of the stock. In order to do so we'll need to take a closer look at the daily changes of the stock, and not just its absolute value. Let's go ahead and use pandas to retrieve teh daily returns for the Apple stock.
"""

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt

# ✅ Download stock data
AAPL = yf.download('AAPL', period='1y')
GOOG = yf.download('GOOG', period='1y')
MSFT = yf.download('MSFT', period='1y')
AMZN = yf.download('AMZN', period='1y')

# ✅ Store companies in a list
company_list = [AAPL, GOOG, MSFT, AMZN]
company_name = ['APPLE', 'GOOGLE', 'MICROSOFT', 'AMAZON']

# ✅ Calculate Daily Return and Smooth it with 7-day Moving Average
for company in company_list:
    company['Daily Return'] = company['Close'].pct_change()
    company['MA for Daily Return'] = company['Daily Return'].rolling(window=7).mean()

# ✅ Plot the Daily Return with Moving Average
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(15, 10))
fig.suptitle('📊 Daily Returns with 7-Day Moving Average', fontsize=18, fontweight='bold')

# ✅ Plot for Apple
axes[0,0].plot(AAPL.index, AAPL['Daily Return'], color='blue', alpha=0.5, label='Daily Return')
axes[0,0].plot(AAPL.index, AAPL['MA for Daily Return'], color='darkblue', linewidth=2, label='7-day MA')
axes[0,0].set_title('🍏 APPLE', fontsize=14, fontweight='bold')
axes[0,0].legend(loc='upper left')
axes[0,0].grid(True, linestyle='--', alpha=0.5)

# ✅ Plot for Google
axes[0,1].plot(GOOG.index, GOOG['Daily Return'], color='green', alpha=0.5, label='Daily Return')
axes[0,1].plot(GOOG.index, GOOG['MA for Daily Return'], color='darkgreen', linewidth=2, label='7-day MA')
axes[0,1].set_title('🔎 GOOGLE', fontsize=14, fontweight='bold')
axes[0,1].legend(loc='upper left')
axes[0,1].grid(True, linestyle='--', alpha=0.5)

# ✅ Plot for Microsoft
axes[1,0].plot(MSFT.index, MSFT['Daily Return'], color='red', alpha=0.5, label='Daily Return')
axes[1,0].plot(MSFT.index, MSFT['MA for Daily Return'], color='darkred', linewidth=2, label='7-day MA')
axes[1,0].set_title('💻 MICROSOFT', fontsize=14, fontweight='bold')
axes[1,0].legend(loc='upper left')
axes[1,0].grid(True, linestyle='--', alpha=0.5)

# ✅ Plot for Amazon
axes[1,1].plot(AMZN.index, AMZN['Daily Return'], color='purple', alpha=0.5, label='Daily Return')
axes[1,1].plot(AMZN.index, AMZN['MA for Daily Return'], color='indigo', linewidth=2, label='7-day MA')
axes[1,1].set_title('📦 AMAZON', fontsize=14, fontweight='bold')
axes[1,1].legend(loc='upper left')
axes[1,1].grid(True, linestyle='--', alpha=0.5)

# ✅ Improve layout
fig.subplots_adjust(hspace=0.3, wspace=0.3)
fig.tight_layout()

# ✅ Show the graph
plt.show()

"""Great, now let's get an overall look at the average daily return using a histogram. We'll use seaborn to create both a histogram and kde plot on the same figure."""

import yfinance as yf
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# ✅ Download stock data
AAPL = yf.download('AAPL', period='1y')
GOOG = yf.download('GOOG', period='1y')
MSFT = yf.download('MSFT', period='1y')
AMZN = yf.download('AMZN', period='1y')

# ✅ Store companies in a list
company_list = [AAPL, GOOG, MSFT, AMZN]
company_name = ['APPLE', 'GOOGLE', 'MICROSOFT', 'AMAZON']
colors = ['blue', 'green', 'red', 'purple']

# ✅ Calculate Daily Return
for company in company_list:
    company['Daily Return'] = company['Close'].pct_change()

# ✅ Create the Plot
plt.figure(figsize=(15, 12))

for i, company in enumerate(company_list, 1):
    plt.subplot(2, 2, i)

    # ✅ Plot the Histogram with KDE Curve
    sns.histplot(company['Daily Return'].dropna(), bins=70, kde=True, color=colors[i-1], alpha=0.6, edgecolor='black')

    # ✅ Add Mean & Median Vertical Lines
    plt.axvline(company['Daily Return'].mean(), color='black', linestyle='dashed', linewidth=1.5, label='Mean')
    plt.axvline(company['Daily Return'].median(), color='darkred', linestyle='dashed', linewidth=1.5, label='Median')

    # ✅ Highlight Volatility Regions
    plt.axvspan(company['Daily Return'].mean() + 2*company['Daily Return'].std(),
                 company['Daily Return'].max(),
                 color='red', alpha=0.1, label='High Volatility')

    plt.axvspan(company['Daily Return'].min(),
                 company['Daily Return'].mean() - 2*company['Daily Return'].std(),
                 color='green', alpha=0.1, label='Low Volatility')

    # ✅ Add Labels and Title
    plt.xlabel('Daily Return', fontsize=12)
    plt.ylabel('Frequency', fontsize=12)
    plt.title(f'📊 {company_name[i - 1]} Daily Return Distribution', fontsize=14, fontweight='bold')

    # ✅ Add Grid, Legend, and Style
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.legend(loc='upper right')

# ✅ Add Global Title
plt.suptitle('📊 Daily Return Distribution with Volatility Zones', fontsize=18, fontweight='bold')

# ✅ Adjust Layout
plt.tight_layout()
plt.subplots_adjust(top=0.92)

# ✅ Show the Plot
plt.show()

"""# 4. What was the correlation between different stocks closing prices?

Correlation is a statistic that measures the degree to which two variables move in relation to each other which has a value that must fall between -1.0 and +1.0. Correlation measures association, but doesn’t show if x causes y or vice versa — or if the association is caused by a third factor[1].

Now what if we wanted to analyze the returns of all the stocks in our list? Let's go ahead and build a DataFrame with all the ['Close'] columns for each of the stocks dataframes.
"""

import yfinance as yf
import pandas as pd
import datetime

# Define the date range
start = datetime.datetime(2020, 1, 1)
end = datetime.datetime(2025, 3, 10)

# List of tech stocks
tech_list = ['AAPL', 'GOOG', 'MSFT', 'AMZN']

# Download data from Yahoo Finance
data = yf.download(tech_list, start=start, end=end)

# Access 'Adj Close' from multi-index columns
closing_df = data['Close']

# Calculate daily percentage change
tech_rets = closing_df.pct_change()

# Display the first 5 rows
tech_rets.head()

"""Now we can compare the daily percentage return of two stocks to check how correlated. First let's see a sotck compared to itself."""

import yfinance as yf
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Fetch stock data
tech_list = ['AAPL', 'GOOG', 'MSFT', 'AMZN']
data = yf.download(tech_list, start='2020-01-01', end='2025-03-10')

# Calculate percentage change
closing_df = data['Close']
tech_rets = closing_df.pct_change()

# Plot the relationship between Google's stock and itself
sns.jointplot(x='GOOG', y='GOOG', data=tech_rets, kind='scatter', color='seagreen')
plt.show()

import yfinance as yf
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Fetch stock data
tech_list = ['AAPL', 'GOOG', 'MSFT', 'AMZN']
data = yf.download(tech_list, start='2020-01-01', end='2025-03-10')

# Calculate percentage change
closing_df = data['Close']
tech_rets = closing_df.pct_change()
# We'll use joinplot to compare the daily returns of Google and Microsoft
sns.jointplot(x='GOOG', y='MSFT', data=tech_rets, kind='scatter')
plt.show()

"""So now we can see that if two stocks are perfectly (and positivley) correlated with each other a linear relationship bewteen its daily return values should occur.

Seaborn and pandas make it very easy to repeat this comparison analysis for every possible combination of stocks in our technology stock ticker list. We can use sns.pairplot() to automatically create this plot
"""

# We can simply call pairplot on our DataFrame for an automatic visual analysis
# of all the comparisons

sns.pairplot(tech_rets, kind='reg')

"""Above we can see all the relationships on daily returns between all the stocks. A quick glance shows an interesting correlation between Google and Amazon daily returns. It might be interesting to investigate that individual comaprison.

While the simplicity of just calling `sns.pairplot()` is fantastic we can also use `sns.PairGrid()` for full control of the figure, including what kind of plots go in the diagonal, the upper triangle, and the lower triangle. Below is an example of utilizing the full power of seaborn to achieve this result.
"""

import yfinance as yf
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Fetch stock data
tech_list = ['AAPL', 'GOOG', 'MSFT', 'AMZN']
data = yf.download(tech_list, start='2020-01-01', end='2025-03-10')

# Calculate percentage change
closing_df = data['Close']
tech_rets = closing_df.pct_change()

# Create the PairGrid
return_fig = sns.PairGrid(tech_rets.dropna())

# Map the plots
return_fig.map_upper(plt.scatter, color='purple')
return_fig.map_lower(sns.kdeplot, cmap='cool_d')
return_fig.map_diag(plt.hist, bins=30, color='steelblue')

# Add a title
plt.suptitle('Pairwise Comparison of Daily Returns', y=1.02)
plt.show()

import yfinance as yf
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# ✅ Fetch stock data
tech_list = ['AAPL', 'GOOG', 'MSFT', 'AMZN']
data = yf.download(tech_list, start='2020-01-01', end='2025-03-10')

# ✅ Get closing prices and daily percentage changes
closing_df = data['Close']
tech_rets = closing_df.pct_change()

# ✅ Set up PairGrid
returns_fig = sns.PairGrid(closing_df)

# ✅ Upper triangle - Scatter plot
returns_fig.map_upper(plt.scatter, color='purple')

# ✅ Lower triangle - KDE plot (Density visualization)
returns_fig.map_lower(sns.kdeplot, cmap='coolwarm', fill=True)

# ✅ Diagonal - Histogram for individual stock distribution
returns_fig.map_diag(plt.hist, bins=30, color='skyblue')

# ✅ Add Title
plt.suptitle('Pairwise Comparison of Stock Prices', fontsize=18)
plt.show()

"""Finally, we could also do a correlation plot, to get actual numerical values for the correlation between the stocks' daily return values. By comparing the closing prices, we see an interesting relationship between Microsoft and Apple."""

import yfinance as yf
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# ✅ Fetch stock data
tech_list = ['AAPL', 'GOOG', 'MSFT', 'AMZN']
data = yf.download(tech_list, start='2020-01-01', end='2025-03-10')

# ✅ Get closing prices and daily percentage changes
closing_df = data['Close']
tech_rets = closing_df.pct_change()

# ✅ Plot
fig, axes = plt.subplots(1, 2, figsize=(12, 4))  # (1 row, 2 columns)

# ✅ Heatmap for Stock Returns Correlation
sns.heatmap(tech_rets.corr(), annot=True, cmap='summer', ax=axes[0])
axes[0].set_title('Correlation of stock return')

# ✅ Heatmap for Closing Prices Correlation
sns.heatmap(closing_df.corr(), annot=True, cmap='summer', ax=axes[1])
axes[1].set_title('Correlation of stock closing price')

# ✅ Adjust Layout
plt.tight_layout()
plt.show()

"""Just like we suspected in our `PairPlot` we see here numerically and visually that Microsoft and Amazon had the strongest correlation of daily stock return. It's also interesting to see that all the technology comapnies are positively correlated.

# 5. How much value do we put at risk by investing in a particular stock?

There are many ways we can quantify risk, one of the most basic ways using the information we've gathered on daily percentage returns is by comparing the expected return with the standard deviation of the daily returns.
"""

import numpy as np
import matplotlib.pyplot as plt

# Drop missing values from tech_rets
rets = tech_rets.dropna()

# Bubble size
area = np.pi * 50  # Increased size for better visibility

# Plotting the Risk vs Expected Return (Volatility vs Mean Returns)
plt.figure(figsize=(10, 8))
plt.scatter(rets.mean(), rets.std(), s=area, color='dodgerblue', alpha=0.7, edgecolors='black', linewidth=1.5)
plt.xlabel('Expected Return')
plt.ylabel('Risk')
plt.title('Risk vs Expected Return for Stocks')

# Annotate each point with stock ticker labels
for label, x, y in zip(rets.columns, rets.mean(), rets.std()):
    plt.annotate(
        label,
        xy=(x, y),
        xytext=(30, 30),
        textcoords='offset points',
        ha='right',
        va='bottom',
        arrowprops=dict(arrowstyle='-', color='blue', connectionstyle='arc3,rad=-0.3')
    )

# Add grid and better aesthetics
plt.grid(True, linestyle='--', alpha=0.7)
plt.show()

"""# 6. Predicting the closing price stock price of APPLE inc:"""

import yfinance as yf
from datetime import datetime

# Get the stock quote using yfinance
df = yf.download('AAPL', start='2012-01-01', end=datetime.now())

# Display the data
print(df.head())

import matplotlib.pyplot as plt

plt.figure(figsize=(16,6))
plt.title('Close Price History')

# Ensure df is sorted by date
df = df.sort_index()

# Plot the stock prices
plt.plot(df.index, df['Close'], label='Close Price', color='blue', alpha=0.8)
plt.plot(df.index, df['High'], label='High Price', color='red', alpha=0.6)
plt.plot(df.index, df['Low'], label='Low Price', color='orange', alpha=0.6)
plt.plot(df.index, df['Open'], label='Open Price', color='green', alpha=0.6)

# Create twin axis for volume
ax = plt.gca()
ax2 = ax.twinx()

# Fix issue: Ensure df['Volume'] is 1D
ax2.fill_between(df.index, df[('Volume', 'AAPL')].values.flatten(), color='gray', alpha=0.1)


# Set labels and legends
ax.set_xlabel('Date', fontsize=18)
ax.set_ylabel('Close Price USD ($)', fontsize=18)
ax2.set_ylabel('Volume', fontsize=18)

# Adjust the scale to avoid overlapping
ax.set_ylim(0, df['Close']['AAPL'].max() * 1.1)
ax2.set_ylim(0, df['Volume']['AAPL'].max())
 # Keep volume scale large

# Improve the legends
ax.legend(loc='upper left')
ax2.legend(['Volume'], loc='upper right')

# Add grid for readability
plt.grid(True, linestyle='--', alpha=0.6)

plt.show()

data = df[('Close', 'AAPL')]  # Correct way to access the column
dataset = data.values.reshape(-1, 1)
scaled_data = scaler.fit_transform(dataset)
print(df.columns)
print(df[('Close', 'AAPL')].head())
print(scaled_data.shape)
print(scaled_data[:5])

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler(feature_range=(0,1))
scaled_data = scaler.fit_transform(dataset)

print(scaled_data.shape)  # Should be (3315, 1)

# Create the training data set
# Create the scaled training data set
train_data = scaled_data[0:int(training_data_len), :]
# Split the data into x_train and y_train data sets
x_train = []
y_train = []

for i in range(60, len(train_data)):
    x_train.append(train_data[i-60:i, 0])
    y_train.append(train_data[i, 0])
    if i<= 61:
        print(x_train)
        print(y_train)
        print()

# Convert the x_train and y_train to numpy arrays
x_train, y_train = np.array(x_train), np.array(y_train)

# Reshape the data
x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))
# x_train.shape

# Initialize training sets
x_train = []
y_train = []

# Create sequences of 60 past values to predict the next value
for i in range(60, len(train_data)):
    x_train.append(train_data[i-60:i, 0])  # Features: Last 60 days
    y_train.append(train_data[i, 0])       # Target: Next day's price

    if i <= 61:  # Print first few values for debugging
        print(f"x_train sample: {x_train[-1]}")
        print(f"y_train sample: {y_train[-1]}\n")

# Convert lists to numpy arrays
x_train, y_train = np.array(x_train), np.array(y_train)

# Reshape x_train for LSTM input
x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))

# Check final shapes
print(f"x_train shape: {x_train.shape}")
print(f"y_train shape: {y_train.shape}")

from keras.models import Sequential
from keras.layers import Dense, LSTM

# Build the LSTM model
model = Sequential()
model.add(LSTM(128, return_sequences=True, input_shape= (x_train.shape[1], 1)))
model.add(LSTM(64, return_sequences=False))
model.add(Dense(25))
model.add(Dense(1))

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(x_train, y_train, batch_size=1, epochs=1)
print(x_train.shape)
print(y_train.shape)

# Prepare the training data again
x_train = []
y_train = []

for i in range(60, len(scaled_data)):
    x_train.append(scaled_data[i-60:i, 0])
    y_train.append(scaled_data[i, 0])

x_train = np.array(x_train)
y_train = np.array(y_train)

# Reshape the data for LSTM
x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))
print(f"x_train shape: {x_train.shape}")
print(f"y_train shape: {y_train.shape}")

from keras.models import Sequential
from keras.layers import Dense, LSTM

# Build the LSTM model
model = Sequential()
model.add(LSTM(128, return_sequences=True, input_shape= (x_train.shape[1], 1)))
model.add(LSTM(64, return_sequences=False))
model.add(Dense(25))
model.add(Dense(1))

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(x_train, y_train, batch_size=1, epochs=1)

# Create the testing data set
# Create a new array containing scaled values from index 1543 to 2002
test_data = scaled_data[training_data_len - 60: , :]
# Create the data sets x_test and y_test
x_test = []
y_test = dataset[training_data_len:, :]
for i in range(60, len(test_data)):
    x_test.append(test_data[i-60:i, 0])

# Convert the data to a numpy array
x_test = np.array(x_test)

# Reshape the data
x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1], 1 ))

# Get the models predicted price values
predictions = model.predict(x_test)
predictions = scaler.inverse_transform(predictions)

# Get the root mean squared error (RMSE)
rmse = np.sqrt(np.mean(((predictions - y_test) ** 2)))
rmse

# Fix: Remove duplicate legend labels and correct color assignments
plt.figure(figsize=(16, 6))
plt.title('Model')
plt.xlabel('Date', fontsize=18)
plt.ylabel('Close Price USD ($)', fontsize=18)

# Plot train data
plt.plot(train.index, train['AAPL'], label="Train", color='blue')

# Plot validation (actual) data
plt.plot(valid.index, valid['AAPL'], label="Validation", color='orange')

# Plot predictions
plt.plot(valid.index, valid['Predictions'], label="Predictions", color='green')

# Ensure a single legend with correct labels
plt.legend(loc='lower right')

# Show the plot
plt.show()

plt.figure(figsize=(16,6))
plt.title('Model')
plt.xlabel('Date', fontsize=18)
plt.ylabel('Close Price USD ($)', fontsize=18)

# Plot the training and validation data
plt.plot(train.index, train.iloc[:, 0], label="Train", color='blue')
plt.plot(valid.index, valid.iloc[:, 0], label="Validation", color='orange')
plt.plot(valid.index, valid['Predictions'], label="Predictions", color='green')

# Fix the legend
plt.legend(loc='upper right')
plt.show()

# Show the valid and predicted prices
valid

"""# Summary
In this notebook, you discovered and explored stock data.

Specifically, you learned:

- How to load stock market data from the YAHOO Finance website using yfinance.
- How to explore and visualize time-series data using Pandas, Matplotlib, and Seaborn.
- How to measure the correlation between stocks.
- How to measure the risk of investing in a particular stock.

Do you have any questions?
Ask your questions in the comments below and I will do my best to answer.

References:
https://www.investopedia.com/terms/c/correlation.asp
[Jose Portilla Udemy Course: Learning Python for Data Analysis and Visualization](https://www.udemy.com/course/learning-python-for-data-analysis-and-visualization/)
"""

